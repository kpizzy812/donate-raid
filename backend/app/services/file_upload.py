# backend/app/services/file_upload.py - ÐŸÐžÐ›ÐÐžÐ¡Ð¢Ð¬Ð® Ð˜Ð¡ÐŸÐ ÐÐ’Ð›Ð•ÐÐÐÐ¯ Ð’Ð•Ð Ð¡Ð˜Ð¯
import os
import uuid
import base64
import io
from typing import Optional
from fastapi import UploadFile, HTTPException
from PIL import Image
import aiofiles

UPLOAD_DIR = "uploads"
ALLOWED_IMAGE_TYPES = {"image/jpeg", "image/png", "image/gif", "image/webp"}
MAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB


class FileUploadService:
    @staticmethod
    async def save_image(file: UploadFile, subfolder: str = "images") -> str:
        """
        Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÑ‚ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ Ð¸ Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ Ð¿ÑƒÑ‚ÑŒ Ðº Ñ„Ð°Ð¹Ð»Ñƒ

        Args:
            file: Ð—Ð°Ð³Ñ€ÑƒÐ¶Ð°ÐµÐ¼Ñ‹Ð¹ Ñ„Ð°Ð¹Ð»
            subfolder: ÐŸÐ¾Ð´Ð¿Ð°Ð¿ÐºÐ° Ð´Ð»Ñ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ñ (images, blog, games, etc.)

        Returns:
            ÐŸÑƒÑ‚ÑŒ Ðº ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð½Ð¾Ð¼Ñƒ Ñ„Ð°Ð¹Ð»Ñƒ Ð¾Ñ‚Ð½Ð¾ÑÐ¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ UPLOAD_DIR
        """

        # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ñ‚Ð¸Ð¿ Ñ„Ð°Ð¹Ð»Ð°
        if file.content_type not in ALLOWED_IMAGE_TYPES:
            raise HTTPException(
                status_code=400,
                detail=f"ÐÐµÐ¿Ð¾Ð´Ð´ÐµÑ€Ð¶Ð¸Ð²Ð°ÐµÐ¼Ñ‹Ð¹ Ñ‚Ð¸Ð¿ Ñ„Ð°Ð¹Ð»Ð°. Ð Ð°Ð·Ñ€ÐµÑˆÐµÐ½Ñ‹: {', '.join(ALLOWED_IMAGE_TYPES)}"
            )

        # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ñ€Ð°Ð·Ð¼ÐµÑ€ Ñ„Ð°Ð¹Ð»Ð°
        file_size = 0
        content = await file.read()
        file_size = len(content)

        if file_size > MAX_FILE_SIZE:
            raise HTTPException(
                status_code=400,
                detail=f"Ð¤Ð°Ð¹Ð» ÑÐ»Ð¸ÑˆÐºÐ¾Ð¼ Ð±Ð¾Ð»ÑŒÑˆÐ¾Ð¹. ÐœÐ°ÐºÑÐ¸Ð¼Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ñ€Ð°Ð·Ð¼ÐµÑ€: {MAX_FILE_SIZE // (1024 * 1024)}MB"
            )

        # Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ ÑƒÐ½Ð¸ÐºÐ°Ð»ÑŒÐ½Ð¾Ðµ Ð¸Ð¼Ñ Ñ„Ð°Ð¹Ð»Ð°
        file_extension = file.filename.split('.')[-1].lower() if file.filename else 'jpg'
        unique_filename = f"{uuid.uuid4().hex}.{file_extension}"

        # Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ Ð´Ð¸Ñ€ÐµÐºÑ‚Ð¾Ñ€Ð¸ÑŽ ÐµÑÐ»Ð¸ Ð½Ðµ ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÐµÑ‚
        upload_path = os.path.join(UPLOAD_DIR, subfolder)
        os.makedirs(upload_path, exist_ok=True)

        # ÐŸÐ¾Ð»Ð½Ñ‹Ð¹ Ð¿ÑƒÑ‚ÑŒ Ðº Ñ„Ð°Ð¹Ð»Ñƒ
        file_path = os.path.join(upload_path, unique_filename)

        # Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ Ñ„Ð°Ð¹Ð»
        async with aiofiles.open(file_path, 'wb') as f:
            await f.write(content)

        # ÐžÐ¿Ñ‚Ð¸Ð¼Ð¸Ð·Ð¸Ñ€ÑƒÐµÐ¼ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ
        try:
            await FileUploadService._optimize_image(file_path)
        except Exception as e:
            print(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð¾Ð¿Ñ‚Ð¸Ð¼Ð¸Ð·Ð°Ñ†Ð¸Ð¸ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ: {e}")

        # Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÐ¼ Ð¾Ñ‚Ð½Ð¾ÑÐ¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¹ Ð¿ÑƒÑ‚ÑŒ
        return os.path.join(subfolder, unique_filename).replace('\\', '/')

    @staticmethod
    def save_base64_image(base64_data: str, subfolder: str = "blog") -> str:
        """
        ÐšÐ¾Ð½Ð²ÐµÑ€Ñ‚Ð¸Ñ€ÑƒÐµÑ‚ base64 Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ Ð² Ñ„Ð°Ð¹Ð» Ð¸ ÑÐ¾Ñ…Ñ€Ð°Ð½ÑÐµÑ‚ ÐµÐ³Ð¾

        Args:
            base64_data: Base64 ÑÑ‚Ñ€Ð¾ÐºÐ° Ñ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸ÐµÐ¼ (data:image/jpeg;base64,...)
            subfolder: ÐŸÐ¾Ð´Ð¿Ð°Ð¿ÐºÐ° Ð´Ð»Ñ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ñ

        Returns:
            ÐŸÑƒÑ‚ÑŒ Ðº ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð½Ð¾Ð¼Ñƒ Ñ„Ð°Ð¹Ð»Ñƒ Ð¾Ñ‚Ð½Ð¾ÑÐ¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ UPLOAD_DIR
        """
        try:
            # ÐŸÐ°Ñ€ÑÐ¸Ð¼ base64 Ð´Ð°Ð½Ð½Ñ‹Ðµ
            if not base64_data.startswith('data:image/'):
                raise ValueError("ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚ base64 Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ")

            # Ð˜Ð·Ð²Ð»ÐµÐºÐ°ÐµÐ¼ Ñ‚Ð¸Ð¿ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ Ð¸ Ð´Ð°Ð½Ð½Ñ‹Ðµ
            header, encoded = base64_data.split(',', 1)
            image_type = header.split('/')[1].split(';')[0].lower()

            # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð¿Ð¾Ð´Ð´ÐµÑ€Ð¶Ð¸Ð²Ð°ÐµÐ¼Ñ‹Ðµ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚Ñ‹
            allowed_types = ['jpeg', 'jpg', 'png', 'gif', 'webp']
            if image_type not in allowed_types:
                raise ValueError(f"ÐÐµÐ¿Ð¾Ð´Ð´ÐµÑ€Ð¶Ð¸Ð²Ð°ÐµÐ¼Ñ‹Ð¹ Ñ‚Ð¸Ð¿ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ: {image_type}")

            # Ð”ÐµÐºÐ¾Ð´Ð¸Ñ€ÑƒÐµÐ¼ base64
            image_data = base64.b64decode(encoded)

            # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ñ€Ð°Ð·Ð¼ÐµÑ€
            if len(image_data) > MAX_FILE_SIZE:
                raise ValueError(f"Ð¤Ð°Ð¹Ð» ÑÐ»Ð¸ÑˆÐºÐ¾Ð¼ Ð±Ð¾Ð»ÑŒÑˆÐ¾Ð¹: {len(image_data)} Ð±Ð°Ð¹Ñ‚")

            # Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ ÑƒÐ½Ð¸ÐºÐ°Ð»ÑŒÐ½Ð¾Ðµ Ð¸Ð¼Ñ Ñ„Ð°Ð¹Ð»Ð°
            file_extension = 'jpg' if image_type == 'jpeg' else image_type
            unique_filename = f"{uuid.uuid4().hex}.{file_extension}"

            # Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ Ð´Ð¸Ñ€ÐµÐºÑ‚Ð¾Ñ€Ð¸ÑŽ ÐµÑÐ»Ð¸ Ð½Ðµ ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÐµÑ‚
            upload_path = os.path.join(UPLOAD_DIR, subfolder)
            os.makedirs(upload_path, exist_ok=True)

            # ÐŸÐ¾Ð»Ð½Ñ‹Ð¹ Ð¿ÑƒÑ‚ÑŒ Ðº Ñ„Ð°Ð¹Ð»Ñƒ
            file_path = os.path.join(upload_path, unique_filename)

            # ÐžÐ¿Ñ‚Ð¸Ð¼Ð¸Ð·Ð¸Ñ€ÑƒÐµÐ¼ Ð¸ ÑÐ¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ
            with Image.open(io.BytesIO(image_data)) as img:
                # ÐšÐ¾Ð½Ð²ÐµÑ€Ñ‚Ð¸Ñ€ÑƒÐµÐ¼ Ð² RGB ÐµÑÐ»Ð¸ Ð½ÑƒÐ¶Ð½Ð¾
                if img.mode in ('RGBA', 'LA', 'P'):
                    img = img.convert('RGB')

                # Ð˜Ð·Ð¼ÐµÐ½ÑÐµÐ¼ Ñ€Ð°Ð·Ð¼ÐµÑ€ ÐµÑÐ»Ð¸ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ ÑÐ»Ð¸ÑˆÐºÐ¾Ð¼ Ð±Ð¾Ð»ÑŒÑˆÐ¾Ðµ
                max_width = 1920
                if img.width > max_width:
                    ratio = max_width / img.width
                    new_height = int(img.height * ratio)
                    img = img.resize((max_width, new_height), Image.Resampling.LANCZOS)

                # Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ Ñ Ð¾Ð¿Ñ‚Ð¸Ð¼Ð¸Ð·Ð°Ñ†Ð¸ÐµÐ¹
                img.save(file_path, 'JPEG', quality=85, optimize=True)

            # Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÐ¼ Ð¾Ñ‚Ð½Ð¾ÑÐ¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¹ Ð¿ÑƒÑ‚ÑŒ
            return os.path.join(subfolder, unique_filename).replace('\\', '/')

        except Exception as e:
            raise ValueError(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ¸ base64 Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ: {str(e)}")

    @staticmethod
    async def _optimize_image(file_path: str, max_width: int = 1920, quality: int = 85):
        """ÐžÐ¿Ñ‚Ð¸Ð¼Ð¸Ð·Ð¸Ñ€ÑƒÐµÑ‚ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ: ÑÐ¶Ð¸Ð¼Ð°ÐµÑ‚ Ð¸ Ð¸Ð·Ð¼ÐµÐ½ÑÐµÑ‚ Ñ€Ð°Ð·Ð¼ÐµÑ€ ÐµÑÐ»Ð¸ Ð½ÑƒÐ¶Ð½Ð¾"""
        try:
            with Image.open(file_path) as img:
                # ÐšÐ¾Ð½Ð²ÐµÑ€Ñ‚Ð¸Ñ€ÑƒÐµÐ¼ Ð² RGB ÐµÑÐ»Ð¸ Ð½ÑƒÐ¶Ð½Ð¾
                if img.mode in ('RGBA', 'LA', 'P'):
                    img = img.convert('RGB')

                # Ð˜Ð·Ð¼ÐµÐ½ÑÐµÐ¼ Ñ€Ð°Ð·Ð¼ÐµÑ€ ÐµÑÐ»Ð¸ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ ÑÐ»Ð¸ÑˆÐºÐ¾Ð¼ Ð±Ð¾Ð»ÑŒÑˆÐ¾Ðµ
                if img.width > max_width:
                    ratio = max_width / img.width
                    new_height = int(img.height * ratio)
                    img = img.resize((max_width, new_height), Image.Resampling.LANCZOS)

                # Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ Ñ Ð¾Ð¿Ñ‚Ð¸Ð¼Ð¸Ð·Ð°Ñ†Ð¸ÐµÐ¹
                img.save(file_path, 'JPEG', quality=quality, optimize=True)

        except Exception as e:
            print(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¾Ð¿Ñ‚Ð¸Ð¼Ð¸Ð·Ð°Ñ†Ð¸Ð¸ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ {file_path}: {e}")

    @staticmethod
    def delete_file(file_path: str) -> bool:
        """Ð£Ð´Ð°Ð»ÑÐµÑ‚ Ñ„Ð°Ð¹Ð»"""
        try:
            full_path = os.path.join(UPLOAD_DIR, file_path)
            if os.path.exists(full_path):
                os.remove(full_path)
                return True
            return False
        except Exception as e:
            print(f"ÐžÑˆÐ¸Ð±ÐºÐ° ÑƒÐ´Ð°Ð»ÐµÐ½Ð¸Ñ Ñ„Ð°Ð¹Ð»Ð° {file_path}: {e}")
            return False

    @staticmethod
    def get_file_url(file_path: str) -> str:
        """
        Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÑ‚ URL Ð´Ð»Ñ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð° Ðº Ñ„Ð°Ð¹Ð»Ñƒ

        Args:
            file_path: ÐŸÑƒÑ‚ÑŒ Ðº Ñ„Ð°Ð¹Ð»Ñƒ Ð¾Ñ‚Ð½Ð¾ÑÐ¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ UPLOAD_DIR

        Returns:
            ÐŸÐ¾Ð»Ð½Ñ‹Ð¹ URL Ðº Ñ„Ð°Ð¹Ð»Ñƒ
        """
        if not file_path:
            return ""

        # Ð£Ð±Ð¸Ñ€Ð°ÐµÐ¼ ÑÐ»ÐµÑˆÐ¸ Ð² Ð½Ð°Ñ‡Ð°Ð»Ðµ Ð¸ Ð½Ð¾Ñ€Ð¼Ð°Ð»Ð¸Ð·ÑƒÐµÐ¼ Ð¿ÑƒÑ‚ÑŒ
        normalized_path = file_path.lstrip('/').replace('\\', '/')

        # Ð˜Ð¡ÐŸÐ ÐÐ’Ð›Ð•ÐÐž: Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÐ¼ Ð¿Ð¾Ð»Ð½Ñ‹Ð¹ URL, Ð¼Ð¸Ð½ÑƒÑ axios baseURL
        import os
        base_url = os.getenv('STATIC_FILES_BASE_URL', 'http://localhost:8001')

        full_url = f"{base_url}/uploads/{normalized_path}"
        print(f"ðŸ”— Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ URL Ñ„Ð°Ð¹Ð»Ð°: {file_path} -> {full_url}")

        return full_url